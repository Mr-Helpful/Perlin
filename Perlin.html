<html>
  <head>
    <title>Perlin noise</title>
    <meta charset="utf-8">
    <style>
      /* dropdown menu control */
      .dropbtn {
        background-color: #4CAF50
        color: white;
        padding: 16px;
        font-size: 16px;
        border: none;
      }

      .dropdown {
        position: relative;
        display: inline-block;
      }

      .dropdown_content {
        display: none;
        position: absolute;
        background-color: #f1f1f1;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown_content a {
        color: black;
        padding: 12px 16px;
        text-decoration: none;
        display: block;
      }

      .dropdown_content a:hover {background-color: #ddd;}

      .dropdown:hover .dropdown_content {display: block;}

      .dropdown:hover .dropbtn {background-color: #3e8e41;}

      /* graph styling */
      path.line {
        fill: none;
        stroke: steelblue;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-width: 2;
        cursor: cell;
      }

      circle.line {
        fill: steelblue;
        opacity: 0;
        cursor: ns-resize;
      }
    </style>
    <!--
    TODO:
    - move noise selector to the top of the graph and use colours instead of names
     - include the name in a tooltip

    - improve the removal transition of points
     - have them move with the path before disappearing
     - this will require a bit of a rework of the way points are updated after removal

    - have a custom update function for translation of a layer
     - this moves the values that have already been calculated instead of having to recalculate
     - then generates new values where they are needed
     - this is an optimisation

    - use dragended to update the Amplitude of parts of the map
    -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script id="Vector.js" type="text/javascript">
      class Vector{
        constructor(x, y){
          this.x = x
          this.y = y
        }
        add(vec){
          return new Vector(this.x + vec.x,
                            this.y + vec.y)
        }
        sub(vec){
          return new Vector(this.x - vec.x,
                            this.y - vec.y)
        }
        mul(A){
          return new Vector(this.x * A,
                            this.y * A)
        }
        length(){
          return (this.x**2 + this.y**2)**0.5
        }
        dot(vec){
          return this.x*vec.x + this.y*vec.y
        }
        normalize(){
          if(this.length() === 0){
            return this
          }
          return this.mul(1/this.length())
        }
        toString(){
          return this.x + " " + this.y
        }
      }
    </script>
    <script id="Heatmap.js" type="text/javascript">
      // taken from https://www.d3-graph-gallery.com/graph/heatmap_basic.html
      // credit to: Yan Holtz

      class Heatmap{
        constructor(){
          this.svg = d3.select("#Heatmap")
          this.iDims = [+this.svg.attr("width"), +this.svg.attr("height")]
          this.dDims = [0, 0]
        }

        // data:
        // the 2D array of height values from the Perlin generator

        // dMax:
        // the theoretical max value for the heightmap
        // this is NOT necessarily the max value in the heightmap

        // iDims:
        // the dimensions of the output image (in px)

        // dDims:
        // the dimensions of the data
        // determined by iDims / resolution
        changeHeatmap(data, dMax, dDims){
          console.log(data)
          console.log(dDims)
          dMax = data.reduce((x, v) => v["v"]>x?v["v"]:x, 0)
          if(this.dDims[0] == dDims[0] && this.dDims[1] == dDims[1]){
            console.log("updating data")
            this.updateData(data, dMax)
          }
          else{
            console.log("updating size")
            this.updateSize(data, dMax, dDims)
          }
        }

        // handles the case where only the colours of the heatmap need to be updated
        // this case is relatively simple
        // we don't even need to update the positions or the translate functions
        updateData(data, dMax){
          console.log(data)
          let c = d3.scaleSequential()
                    .interpolator(defaultPerlin.cScale)
                    .domain([-dMax, dMax])

          this.svg.selectAll("rect")
                  .data(data, d => (d.x + "," + d.y))
                  .join(enter => enter,
                        update => update.style("fill", d => c(d.v)),
                        exit => exit)
        }

        updateSize(data, dMax, dDims){
          let x = d3.scaleBand()
                    .range([0, this.iDims[0]])
                    .domain([...Array(dDims[0]).keys()])

          let y = d3.scaleBand()
                    .range([0, this.iDims[1]])
                    .domain([...Array(dDims[1]).keys()])

          let c = d3.scaleSequential()
                    .interpolator(defaultPerlin.cScale)
                    .domain([-dMax, dMax])

          this.svg.selectAll("rect")
                  .data(data, d => (d.x + "," + d.y))
                  .join(enter => enter.append("rect")
                                      .attr("x", d => x(d.x))
                                      .attr("y", d => y(d.y))
                                      .attr("width", x.bandwidth())
                                      .attr("height", y.bandwidth())
                                      .style("fill", d => c(d.v)),
                        update => update.attr("x", d => x(d.x))
                                        .attr("y", d => y(d.x))
                                        .attr("width", x.bandwidth())
                                        .attr("height", y.bandwidth())
                                        .style("fill", d => c(d.v)),
                        exit => exit.remove())


          this.dDims = dDims
        }
      }
    </script>
    <script id="Perlin.js" type="text/javascript">
      class Perlin extends Heatmap{
        constructor(lFunc, res){
          super()
          this.resolution = res
          this.tableSize = 256
          this.lFunc = lFunc
          this.perlinVals = []
        }

        set res(val){
          this.resolution = val
          this.changeHeatmap(this.getData(), this.getMaxVal())
        }

        printLevels(){
          console.log(this.perlinVals.map(v => v.slice(0,2)))
        }

        zip(rows){
          return rows[0].map((_, c) => rows.map(row => row[c]))
        }

        updateHMap(){
          let dDims = this.iDims.map(x => Math.floor(x/this.resolution))
          this.changeHeatmap(this.getData(dDims), this.getMaxVal(), dDims)
        }

        getData(dDims){
          let perlinData = this.perlinVals.map(pDatum => {
            let f = pDatum[0]/this.resolution
            let d = [f, ...pDatum.slice(1)]
            return this.queryPoints(d, dDims)
          })
          return this.zip(perlinData).map(r => {
            return r.reduce((v,d) => {
              v["v"] += d["v"]
              return v
            })
          })
        }

        getMaxVal(){
          return this.perlinVals.reduce((a, b) => a + b[1], 0) * 2**1.5
        }

        addLevel(fDatum){
          fDatum = this.modFDatum(fDatum)
          let data = this.getLevel(fDatum)
          this.perlinVals.push(data)
        }

        editLevel(fDatum){
          console.log("editing level")
          fDatum = [2**fDatum[0], 2**fDatum[1]]
          let [d, i] = this.fIndex(fDatum[0])
          if(i == -1){
            console.warn("Trying to edit a non-existant layer.")
            console.warn("This shouldn't happen, adding a new layer instead")
            this.addLevel(fDatum)
          }
          else if(fDatum[1] != d[1]){
            console.log("changing amplitude")
            this.perlinVals[i][1] = fDatum[1]
          }
          else{
            console.log("refreshing level")
            fDatum = this.getLevel(fDatum)
            this.perlinVals[i] = fDatum
          }
        }

        delLevel(fDatum){
          fDatum = this.modFDatum(fDatum)
          this.perlinVals = this.perlinVals.filter(d => d[0] != fDatum[0])
        }

        getLevel(fDatum){
          return [...fDatum, this.generateHashes(), this.generateVecs()]
        }

        fIndex(f){
          return this.perlinVals.reduce((x, v, i) => v[0]==f?[v, i]:x, [-1, -1])
        }

        generateVecs(){
          let v = new Array(this.tableSize).fill(0)

          function genVec(v, i){
            let t = Math.random() * Math.PI * 2
            let A = Math.random()
            A = 1
            let x = A * Math.sin(t)
            let y = A * Math.cos(t)
            return [x, y]
          }

          return v.map(genVec)
        }

        generateHashes(){
          let h = new Array(this.tableSize).fill(0)

          h = h.map((v, i) => i)
          h.forEach((v, i) => {
            let j = Math.floor(Math.random() * h.length)
            h[i] = h[j]
            h[j] = v
          })

          // this simply doubles the array
          h.push(...h)
          return h
        }

        queryPoints(layer, dDims){
          let iFunc = (x, y) => this.index(...(layer.slice(-2)), x, y)
          let [f, A] = layer.slice(0, 2)
          let pQuery = (x, y) => this.query(f, A, iFunc, this.lFunc, this.tableSize, x, y)


          let [w, h] = dDims
          w = new Array(w).fill(0)
          h = new Array(h).fill(0)

          // setting up a blank array of points to be filled
          let points = []

          // using a forEach method is quicker than a for loop
          w.forEach((_, x) => {
            h.forEach((_, y) => {
              points.push({"x":x,
                           "y":y,
                           "v":pQuery(x, y)})
            })
          })

          return points
        }

        index(hash, vecs, x, y){
          return vecs[hash[hash[x] + y]]
        }

        splitInt(v, f, tableSize){
          v /= f
          v %= tableSize
          let t = Math.floor(v)
          v -= t
          return [t, (t + 1) % tableSize, v]
        }

        query(f, A, iFunc, lFunc, tableSize, x, y){
          let [x0, x1, xf] = this.splitInt(x, f, tableSize)
          let [y0, y1, yf] = this.splitInt(y, f, tableSize)

          let v11, v12, v21, v22
          v11 = iFunc(x0, y0)
          v12 = iFunc(x0, y1)
          v21 = iFunc(x1, y0)
          v22 = iFunc(x1, y1)

          v11 = this.dot(...v11, xf, yf)
          v12 = this.dot(...v12, xf, 1-yf)
          v21 = this.dot(...v21, 1-xf, yf)
          v22 = this.dot(...v22, 1-xf, 1-yf)

          v11 = this.lerp(v11, v21, lFunc(xf))
          v12 = this.lerp(v12, v22, lFunc(xf))

          return A * this.lerp(v11, v12, lFunc(yf))
        }

        dot(x1, y1, x2, y2){
          return x1*x2 + y1*y2
        }

        lerp(v1, v2, t){
          return v1 * (1 - t) + v2 * t
        }

      }
    </script>
    <script id="Defaults.js" type="text/javascript">
      defaultLevels = {"Custom":[[0, 0], [10, 0]],
                       "Violet":[[0, -20],
                                 [2, -16],
                                 [4, -12],
                                 [6, -8],
                                 [8, -4]],
                       "White": [[0, 0],
                                 [2, 0],
                                 [4, 0],
                                 [6, 0],
                                 [8, 0]],
                       "Brown": [[0, 0],
                                 [2, -4],
                                 [4, -8],
                                 [6, -12],
                                 [8, -16]],
                       "Pink":  [[0, 0],
                                 [2, -2],
                                 [4, -4],
                                 [6, -6],
                                 [8, -8]],
                       "Blue":  [[0, -10],
                                 [2, -8],
                                 [4, -6],
                                 [6, -4],
                                 [8, -2]]}
      defaultPerlin = {"lFunc": t => 6*t**5-15*t**4+10*t**3,
                       "cScale": d3.interpolateViridis}
    </script>
    <script id="LevelClass.js" type="text/javascript">
      class Levels{
        constructor(perlin, defaults, defaultName){
          this.points = []
          this.perlin = perlin
          this.svg = d3.select("#Levels")

          this.setupLevels(defaults, defaultName)
        }

        setupLevels(defaults, defaultName){
          let dims = this.getDims(defaults["margin"])
          this.createFocus(defaults["margin"])
          this.createAxis(dims, defaults["margin"])
          let dragFunc = this.createDraggable()
        }

        getDims(margin){
          w = +this.svg.attr("width") - margin.left - margin.right,
          h = +this.svg.attr("height") - margin.top - margin.bottom
          return [w, h]
        }

        createFocus(dims, margin){
          svg.append('rect')
             .attr('class', 'zoom')
             .attr('fill', 'none')
             .attr('pointer-events', 'all')
             .attr('width', dims[0])
             .attr('height', dims[1])
             .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

          this.focus = svg.append("g")
                          .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        }

        createAxis(dims, margin){
          this.addAxisLine(dims, margin)
          this.addAxisLabels(dims)
        }

        addAxisLine(dims, margin){
          this.x = d3.scaleLinear()
                    .rangeRound([0, dims[0]])
                    .domain([0, 8])

          this.focus.append('g')
                    .attr('class', 'axis axis--x')
                    .attr('transform', 'translate(0,' + height + ')')
                    .call(d3.axisBottom(this.x))

          this.y = d3.scaleLinear()
                    .rangeRound([0, dims[1]])
                    .domain([-20, 0])
                    .clamp(true)

          this.focus.append('g')
                    .attr('class', 'axis axis--y')
                    .call(d3.axisLeft(this.y))
        }

        addAxisLabels(dims){
          this.focus.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "top")
                    .attr("x", dims[0] / 2 - 50)
                    .attr("y", dims[1] + 40)
                    .text("Frequency (log2)")

          this.focus.append("text")
                    .attr("class", "y label")
                    .attr("text-anchor", "top")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -dims[1] / 2 - 50)
                    .attr("y", -40)
                    .text("Amplitude (log2)")
        }

        createDraggable(){
          //let perlin, x, y, line = this.perlin, this.x, this.y, this.line
          function dragstarted(d){
            d3.select(this).raise().classed('active', true)
          }

          function dragged(d){
            d[1] = y.invert(d3.event.y)
            d3.select(this)
              .attr('cx', x(d[0]))
              .attr('cy', y(d[1]))
            focus.select('path').attr('d', line)
          }

          function dragended(d){
            d3.select(this).classed('active', false)
            perlin.editLevel(d)
            perlin.updateHMap()
          }
        }

        return d3.drag()
                 .on("start", dragstarted)
                 .on("drag",  dragged)
                 .on("end",   dragended)
      }
    </script>
    <script id="Levels.js" type="text/javascript">
      // credit to:
      // Denise Mauldin (draggable line graph)
      // https://bl.ocks.org/denisemauldin/538bfab8378ac9c3a32187b4d7aed2c2

      function initLevels(perlin, defaultLevels, defaultLevel){
        let svg = d3.select("#Levels"),//<
            margin = {top: 50, right: 20, bottom: 50, left: 50},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom

        let x = d3.scaleLinear()
                  .rangeRound([0, width])

        let y = d3.scaleLinear()
                  .rangeRound([height, 0])

        let xAxis = d3.axisBottom(x),
            yAxis = d3.axisLeft(y)//>

        let line = d3.line()
                     .x(function(d) { return x(d[0]) })
                     .y(function(d) { return y(d[1]) })

        let drag = d3.drag()//<
                     .on('start', dragstarted)
                     .on('drag', dragged)
                     .on('end', dragended)


        let points = []


        svg.append('rect')
           .attr('class', 'zoom')
           .attr('fill', 'none')
           .attr('pointer-events', 'all')
           .attr('width', width)
           .attr('height', height)
           .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

        let focus = svg.append("g")
                       .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

        focus.append("text")
             .attr("class", "x label")
             .attr("text-anchor", "top")
             .attr("x", width / 2 - 50)
             .attr("y", height + 40)
             .text("Frequency (log2)")

        focus.append("text")
             .attr("class", "y label")
             .attr("text-anchor", "top")
             .attr("transform", "rotate(-90)")
             .attr("x", -height / 2 - 50)
             .attr("y", -40)
             .text("Amplitude (log2)")

        x.domain([0, 8])
        y.domain([-20, 0])
        y.clamp(true)//>

        function updateGraph(points, i = -1){
          T = 500
          const t = focus.transition()
                         .duration(T)

          let p = focus.select("path.line")
          let c = focus.selectAll('circle.line')
          if(i != -1){
            p.datum(points)
             .transition(t)
             .attr("d", line)

            points.splice(i, 1)
          }
          p.datum(points)
           .on("click", addPoint)
           .transition()
           .duration(0)
           .delay(T)
           .attr("d", line)

          c.data(points, d => d[0])
           .join(enter => enter.append('circle')
                               .attr("class", "line")
                               .attr('r', 5.0)
                               .attr('cx', d => x(d[0]))
                               .attr('cy', d => y(d[1]))
                               .on("click", removePoint)
                               .each(d => perlin.addLevel(d))
                               .call(enter => {
                               return enter.transition(t)
                                           .style("opacity", 1)})
                               .call(drag),
                 update => update.each(d => perlin.editLevel(d))
                                 .call(update => {
                                 return update.transition(t)
                                              .attr('cx', d => x(d[0]))
                                              .attr('cy', d => y(d[1]))
                                 }),
                 exit => exit.each(d => perlin.delLevel(d))
                             .call(exit => {
                             return exit.transition(t)
                                        .style("opacity", 0)
                                        .remove()}))

          perlin.updateHMap()
        }

        function addPoint(d){
          let coords = d3.mouse(this)

          let n = [x.invert(coords[0]),
                   y.invert(coords[1])]

          points.push(n)
          points.sort((a, b) => a[0] - b[0])
          updateGraph(points)
        }

        function removePoint(d){
          d3.event.preventDefault()

          let i = points.indexOf(d)

          if(i > 0 && i < points.length - 1){
            points = flattenPoint(points, i)
            updateGraph(points, i)
          }
        }

        function flattenPoint(points, i){
          const x = points[i][0]
          const [x1, y1] = points[i - 1]
          const [x2, y2] = points[i + 1]
          const t = (x - x1) / (x2 - x1)
          let y = y2 * t + y1 * (1 - t)
          points[i][1] = y
          return points
        }

        focus.append("path")
             .attr("class", "line")

        focus.append('g')
             .attr('class', 'axis axis--x')
             .attr('transform', 'translate(0,' + height + ')')
             .call(xAxis)

        focus.append('g')
             .attr('class', 'axis axis--y')
             .call(yAxis)

        function dragstarted(d) {
          d3.select(this).raise().classed('active', true)
        }

        function dragged(d) {
          d[1] = y.invert(d3.event.y)
          d3.select(this)
            .attr('cx', x(d[0]))
            .attr('cy', y(d[1]))
          focus.select('path').attr('d', line)
        }

        function dragended(d) {
          d3.select(this).classed('active', false)
          perlin.editLevel(d)
          perlin.updateHMap()
        }

        // updates the Levels graph with one of the default set of points
        function setDefault(d){
          // sets the dropdown menu to display the correct kind of noise
          d3.select("#defaultSelect")
            .select(".dropbtn")
            .text(d)

          points = defaultLevels[d]
          // if it's not the custom setting
          if(d != "Custom"){
            // then we perform a shallow copy to prevent the preset from being edited
            // the default points given are a nested list
            // so we need to perform a copy on two layers
            points = points.map(v => [...v])
          }

          updateGraph(points)
        }

        d3.select("#defaultSelect")
          .select("div.dropdown_content")
          .selectAll("a")
          .data(Object.keys(defaultLevels))
          .enter()
          .append("a")
          .text(d => d)
          .on("click", setDefault)

        setDefault(defaultLevel)
      }
    </script>
    <script id="Main.js" type="text/javascript">
      function init(){
        let p = new Perlin(defaultPerlin["lFunc"], 2)
        initLevels(p, defaultLevels, "Violet")
      }
    </script>
  </head>
  <body  onload="init()">
    <div class="dropdown" id="defaultSelect">
      <button class="dropbtn">Noise Type</button>
      <div class="dropdown_content">
      </div>
    </div>
    <svg id="Levels" width=1000 height=500></svg>
    <svg id="Heatmap" width=500 height=500></svg>
    <p id="label">Placeholder</p>
  </body>
</html>
