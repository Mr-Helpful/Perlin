<html>
  <head>
    <title>Perlin noise</title>
    <meta charset="utf-8">
    <style>
      /* dropdown menu control */
      .dropbtn {
        background-color: #4CAF50
        color: white;
        padding: 16px;
        font-size: 16px;
        border: none;
      }

      .dropdown {
        position: relative;
        display: inline-block;
      }

      .dropdown_content {
        display: none;
        position: absolute;
        background-color: #f1f1f1;
        min-width: 160px;
        box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
        z-index: 1;
      }

      .dropdown_content a {
        color: black;
        padding: 12px 16px;
        text-decoration: none;
        display: block;
      }

      .dropdown_content a:hover {background-color: #ddd;}

      .dropdown:hover .dropdown_content {display: block;}

      .dropdown:hover .dropbtn {background-color: #3e8e41;}

      /* graph styling */
      path.line {
        fill: none;
        stroke: steelblue;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-width: 2;
        cursor: cell;
      }

      circle.line {
        fill: steelblue;
        opacity: 0;
        cursor: ns-resize;
      }
    </style>
    <!--
    TODO:
    - move noise selector to the top of the graph and use colours instead of names
     - include the name in a tooltip

    - improve the removal transition of points
     - have them move with the path before disappearing
     - this will require a bit of a rework of the way points are updated after removal

    - change out the implementation of the perlin noise
     - a class is overkill for the operations required
    -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="https://unpkg.com/d3-interpolate-path/build/d3-interpolate-path.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/seedrandom/2.3.10/seedrandom.min.js"></script>
    <script id="Vector" type="text/javascript">
      class Vector{
        constructor(x, y){
          this.x = x
          this.y = y
        }
        add(vec){
          return new Vector(this.x + vec.x,
                            this.y + vec.y)
        }
        sub(vec){
          return new Vector(this.x - vec.x,
                            this.y - vec.y)
        }
        mul(A){
          return new Vector(this.x * A,
                            this.y * A)
        }
        length(){
          return (this.x**2 + this.y**2)**0.5
        }
        dot(vec){
          return this.x*vec.x + this.y*vec.y
        }
        normalize(){
          if(this.length() === 0){
            return this
          }
          return this.mul(1/this.length())
        }
        toString(){
          return this.x + " " + this.y
        }
      }
    </script>
    <script id="Perlin" type="text/javascript">
      // using a class is overkill (and will therefore slow this down)
      // we can simply keep a nested array for each value and an amplitude to multiply by
      // therefore, functional programming is better for this purpose
      function generateVecs(tableSize){
        let v = new Array(tableSize).fill(0)

        function genVec(v, i){
          let a = Math.random() * Math.PI * 2
          let x = Math.sin(a)
          let y = Math.cos(a)
          return [x, y]
        }

        return v.map(genVec)
      }

      function generateHashes(tableSize){
        let h = new Array(tableSize).fill(0)

        h = h.map((v, i) => i)
        h.forEach((v, i) => {
          let j = Math.floor(Math.random() * h.length)
          h[i] = h[j]
          h[j] = v
        })

        // this simply doubles the array
        h.push(...h)
        return h
      }

      function queryPoints(setup, w){
        let t = new Array(w).fill(0)
        let tableSize = setup[3].length

        // setting up a blank array of points to be filled
        let points = []

        // using a forEach method is quicker than a for loop
        [...t].forEach((v, x) => {
          [...t].forEach((v, y) => {
            points.push({"x":x,
                         "y":y,
                         "v":query(x, y, ...setup, tableSize)})
            })
          })

        return points
      }

      function query(x, y, f, lFunc, hashTable, vecsTable, tableSize){
        let x1, x2, xf, y1, y2, yf, t
        let vals = [x, y].map(v => {
          v *= f
          v %= tableSize
          t = Math.floor(v)
          v -= t
          return [t, (t + 1) % tableSize, v]
        })
        [[x1, x2, xf], [y1, y2, yf]] = vals

        let v11, v12, v21, v22
        v11 = hashTable[hashTable[x1] + y1]
        v12 = hashTable[hashTable[x1] + y2]
        v21 = hashTable[hashTable[x2] + y1]
        v22 = hashTable[hashTable[x2] + y2]

        v11 = vecsTable[v11]
        v12 = vecsTable[v12]
        v21 = vecsTable[v21]
        v22 = vecsTable[v22]

        v11 = dot(...v11, xf, yf)
        v12 = dot(...v12, xf, 1-yf)
        v21 = dot(...v21, 1-xf, yf)
        v22 = dot(...v22, 1-xf, 1-yf)

        v11 = lerp(v11, v21, lFunc(xf))
        v12 = lerp(v12, v22, lFunc(xf))
        return lerp(v11, v12, lFunc(yf))
      }

      dot(x1, y1, x2, y2){
        return x1*x2 + y1*y2
      }

      lerp(v1, v2, t){
        return v1 * t + v2 * (1-t)
      }

      class Perlin{
        TableSize = 256
        lFuncs = {"Linear":t => (t),
                  "Smooth":t => (t * t * (3 - 2 * t)),
                  "Perlin":t => (t * t * t * (10 + t * (6 * t - 15)))}

        constructor(f, funcName = 0){
          this.f = f
          this.lFunc = this.lFuncs[funcName] || this.lFuncs["Linear"]
          this.vecsTable = new Array(this.TableSize).fill(0)
          this.hashTable = new Array(this.TableSize * 2).fill(0)

          this.generateVecs()
          this.generateHashes()
        }

        generateVecs(){
          function genVec(v, i){
            let a = Math.random() * Math.PI * 2
            let x = Math.sin(a)
            let y = Math.cos(a)
            return [x, y]
          }
          this.vecsTable = this.vecsTable.map(genVec)
        }

        generateHashes(){
          let h = new Array(this.TableSize).fill(0)
          h = h.map((v, i) => i)
          h.forEach((v, i) => {
            let j = Math.floor(Math.random() * h.length)
            h[i] = h[j]
            h[j] = v
          })
          this.hashTable = this.hashTable.map((v, i) => {
            return h[i % this.TableSize]
          })
        }

        query(x, y){
          let x1, x2, xf, y1, y2, yf, t
          let vals = [x, y].map(v => {
            v *= this.f
            v %= this.TableSize
            t = Math.floor(v)
            v -= t
            return [t, (t + 1) % this.TableSize, v]
          })
          [[x1, x2, xf], [y1, y2, yf]] = vals

          let v11, v12, v21, v22
          v11 = this.hashTable[this.hashTable[x1] + y1]
          v12 = this.hashTable[this.hashTable[x1] + y2]
          v21 = this.hashTable[this.hashTable[x2] + y1]
          v22 = this.hashTable[this.hashTable[x2] + y2]

          v11 = this.vecsTable[v11]
          v12 = this.vecsTable[v12]
          v21 = this.vecsTable[v21]
          v22 = this.vecsTable[v22]

          v11 = this.dot(...v11, xf, yf)
          v12 = this.dot(...v12, xf, 1-yf)
          v21 = this.dot(...v21, 1-xf, yf)
          v22 = this.dot(...v22, 1-xf, 1-yf)

          v11 = lerp(v11, v21, this.lFunc(xf))
          v12 = lerp(v12, v22, this.lFunc(xf))
          return lerp(v11, v12, this.lFunc(yf))
        }

        dot(x1, y1, x2, y2){
          return x1*x2 + y1*y2
        }

        lerp(v1, v2, t){
          return v1 * t + v2 * (1-t)
        }
      }


    </script>
    <script id="Defaults" type="text/javascript">
      defaults = {"Custom": [[0, 0], [1024, 0]],
                  "Violet":[[Math.pow(2, 0), Math.pow(2, -20)],
                            [Math.pow(2, 2), Math.pow(2, -16)],
                            [Math.pow(2, 4), Math.pow(2, -12)],
                            [Math.pow(2, 6), Math.pow(2, -8)],
                            [Math.pow(2, 8), Math.pow(2, -4)],
                            [Math.pow(2, 10), Math.pow(2, 0)]],
                  "White": [[Math.pow(2, 0), Math.pow(2, 0)],
                            [Math.pow(2, 2), Math.pow(2, 0)],
                            [Math.pow(2, 4), Math.pow(2, 0)],
                            [Math.pow(2, 6), Math.pow(2, 0)],
                            [Math.pow(2, 8), Math.pow(2, 0)],
                            [Math.pow(2, 10), Math.pow(2, 0)]],
                  "Brown": [[Math.pow(2, 0), Math.pow(2, 0)],
                            [Math.pow(2, 2), Math.pow(2, -4)],
                            [Math.pow(2, 4), Math.pow(2, -8)],
                            [Math.pow(2, 6), Math.pow(2, -12)],
                            [Math.pow(2, 8), Math.pow(2, -16)],
                            [Math.pow(2, 10), Math.pow(2, -20)]],
                  "Pink":  [[Math.pow(2, 0), Math.pow(2, 0)],
                            [Math.pow(2, 2), Math.pow(2, -2)],
                            [Math.pow(2, 4), Math.pow(2, -4)],
                            [Math.pow(2, 6), Math.pow(2, -6)],
                            [Math.pow(2, 8), Math.pow(2, -8)],
                            [Math.pow(2, 10), Math.pow(2, -10)]],
                  "Blue":  [[Math.pow(2, 0), Math.pow(2, -10)],
                            [Math.pow(2, 2), Math.pow(2, -8)],
                            [Math.pow(2, 4), Math.pow(2, -6)],
                            [Math.pow(2, 6), Math.pow(2, -4)],
                            [Math.pow(2, 8), Math.pow(2, -2)],
                            [Math.pow(2, 10), Math.pow(2, 0)]]}
    </script>
    <script id="Levels" type="text/javascript">
      // credit to:
      // Denise Mauldin (draggable line graph)
      // https://bl.ocks.org/denisemauldin/538bfab8378ac9c3a32187b4d7aed2c2

      function initLevels(){
        let svg = d3.select("svg"),
            margin = {top: 50, right: 20, bottom: 30, left: 50},
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom

        let x = d3.scaleLinear()
                  .rangeRound([0, width])

        let y = d3.scaleLinear()
                  .rangeRound([height, 0])

        let xAxis = d3.axisBottom(x),
            yAxis = d3.axisLeft(y)

        let line = d3.line()
                     .x(function(d) { return x(d[0]) })
                     .y(function(d) { return y(d[1]) })

        let drag = d3.drag()
                     .on('start', dragstarted)
                     .on('drag', dragged)
                     .on('end', dragended)

        let points = []

        svg.append('rect')
           .attr('class', 'zoom')
           .attr('fill', 'none')
           .attr('pointer-events', 'all')
           .attr('width', width)
           .attr('height', height)
           .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

        let focus = svg.append("g")
                       .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

        x.domain([0, 1024])
        y.domain([0, 1])
        y.clamp(true)

        function updateGraph(points, i = -1){
          T = 500
          const t = focus.transition()
                         .duration(T)

          let p = focus.select("path.line")
          if(i != -1){
            p.datum(points)
             .transition(T)
             .attr("d", line)

            points.splice(i, 1)
          }
          p.datum(points)
           .on("click", addPoint)
           .transition()
           .duration(0)
           .delay(T)
           .attr("d", line)

          let c = focus.selectAll('circle.line')
          c.data(points, d => d[0])
           .join(enter => enter.append('circle')
                               .attr("class", "line")
                               .attr('r', 5.0)
                               .attr('cx', function(d) { return x(d[0])  })
                               .attr('cy', function(d) { return y(d[1]) })
                               .on("click", removePoint)
                               .call(enter => {
                               return enter.transition(t)
                                           .style("opacity", 1)})
                               .call(drag),
                 update => update.call(update => {
                                 return update.transition(t)
                                              .attr('cx', d => x(d[0]))
                                              .attr('cy', d => y(d[1]))
                                 }),
                 exit => exit.call(exit => {
                             return exit.transition(t)
                                        .style("opacity", 0)
                                        .remove()}))
        }

        function addPoint(d){
          let coords = d3.mouse(this)

          let n = [x.invert(coords[0]),
                   y.invert(coords[1])]

          points.push(n)
          points.sort((a, b) => a[0] - b[0])
          updateGraph(points)
        }

        function removePoint(d){
          d3.event.preventDefault()

          let i = points.indexOf(d)

          if(i > 0 && i < points.length - 1){
            points = flattenPoint(points, i)
            updateGraph(points, i)
          }
        }

        function flattenPoint(points, i){
          const x = points[i][0]
          const [x1, y1] = points[i - 1]
          const [x2, y2] = points[i + 1]
          const t = (x - x1) / (x2 - x1)
          let y = y2 * t + y1 * (1 - t)
          points[i][1] = y
          return points
        }

        focus.selectAll('circle')
             .call(drag)

        focus.append("path")
             .attr("class", "line")
        setDefault("Custom")

        focus.append('g')
             .attr('class', 'axis axis--x')
             .attr('transform', 'translate(0,' + height + ')')
             .call(xAxis)

        focus.append('g')
             .attr('class', 'axis axis--y')
             .call(yAxis)

        function dragstarted(d) {
          d3.select(this).raise().classed('active', true)
        }

        function dragged(d) {
          d[1] = y.invert(d3.event.y)
          d3.select(this)
            .attr('cx', x(d[0]))
            .attr('cy', y(d[1]))
          focus.select('path').attr('d', line)
        }

        function dragended(d) {
          d3.select(this).classed('active', false)
        }

        // updates the Levels graph with one of the default set of points
        function setDefault(d){
          // sets the dropdown menu to display the correct kind of noise
          d3.select("#defaultSelect")
            .select(".dropbtn")
            .text(d)

          points = defaults[d]
          // if it's not the custom setting
          if(d != "Custom"){
            // then we perform a shallow copy to prevent the preset from being edited
            // the default points given are a nested list
            // so we need to perform a copy on two layers
            points = points.map(v => [...v])
          }

          updateGraph(points)
        }

        d3.select("#defaultSelect")
          .select("div.dropdown_content")
          .selectAll("a")
          .data(Object.keys(defaults))
          .enter()
          .append("a")
          .text(d => d)
          .on("click", setDefault)
      }
    </script>
    <script id="Sampler", type="text/javascript">
      // key terms:
      // resolution - the number of points per pixel
      let hMap = []

      function genHMap(iw, ih){
        let i, j
        for(j = 0; j < ih; j++){
          for(i = 0; i < iw; i++){
            hMap.append({"x":i,
                         "y":j,
                         "v":0})
          }
        }
      }

      function sample(Perlin, iw, ih, A){
        const k = Math.max(iw, ih) / Perlin.w

        let v, x, y, i, j, data = []
        for(j = 0; j < ih; j++){
          y = j / k
          for(i = 0; i < iw; i++){
            x = i / k
            v = Perlin.query(x, y)
            data.append({"x":i,
                         "y":j,
                         "v":v * A})
          }
        }

        return [data, iw, ih]
      }

      function draw(name, data, iw, ih){

      }
    </script>
    <script id="Heatmap" type="text/javascript">
      // taken from https://www.d3-graph-gallery.com/graph/heatmap_basic.html
      // credit to: Yan Holtz

      class Heatmap{
        constructor(data, sWidth, sHeight, dWidth, dHeight){
          this.sDims = [sWidth, sHeight]
          this.dDims = [dWidth, dHeight]
        }

        changeHeatmap(data, dMax , sDims, dDims){
          if(this.sDims == sDims && this.dDims == dDims){
            this.updateSize(data, dMax , sDims, dDims)
          }
          else{
            this.updateData(data, dMax)
          }
        }

        // handles the case where only the colours of the heatmap need to be updated
        // this case is relatively simple
        // we don't even need to update the positions or the translate functions
        updateData(data, dMax){
          let c
          c = d3.scaleLinear()
                .range(["white", "#69b3a2"])
                .domain([0, dMax])

          svg.selectAll("rect")
             .data(data, d => (d.x + "," + d.y))
             .update()
             .style("fill", d => c(d.v))
        }

        updateSize(data, dMax, sDims, dDims){
          let x, y, c
          x = d3.scaleBand()
                .range([0, sDims[0]])
                .domain([0, dDims[0]])
                .padding(0.01)

          y = d3.scaleBand()
                .range([sDims[1], 0])
                .domain([0, dDims[1]])
                .padding(0.01)

          c = d3.scaleLinear()
                .range(["white", "#69b3a2"])
                .domain([0, dMax])

          svg.selectAll("rect")
             .data(data, d => (d.x + "," + d.y))
             .join(enter => enter.append("rect")
                                 .attr("x", d => x(d.x))
                                 .attr("y", d => y(d.y))
                                 .attr("width", x.bandwidth())
                                 .attr("height", y.bandwidth())
                                 .style("fill", d => c(d.v)),
                   update => update.attr("x", d => x(d.x))
                                   .attr("y", d => y(d.x))
                                   .attr("width", x.bandwidth())
                                   .attr("height", y.bandwidth())
                                   .style("fill", d => c(d.v)),
                   exit => exit.remove())

          this.sDims = sDims
          this.dDims = dDims
        }
      }
    </script>
  </head>
  <body>
    <div class="dropdown" id="defaultSelect">
      <button class="dropbtn">Noise Type</button>
      <div class="dropdown_content">
      </div>
    </div>
    <svg id="Levels" width=1000 height=500 onload="initLevels()"></svg>
    <svg id="Perlin"></svg>
    <p id="label">Placeholder</p>
  </body>
</html>
