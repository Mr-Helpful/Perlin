<html>
  <head>
    <title>Perlin noise</title>
    <meta charset="utf-8">
    <style id="graph">
      path.line {
        fill: none;
        stroke: steelblue;
        stroke-linejoin: round;
        stroke-linecap: round;
        stroke-width: 2;
        cursor: cell;
      }

      circle.line {
        fill: steelblue;
        opacity: 0;
        cursor: ns-resize;
      }

      circle.default {
        opacity: 1;
        cursor: pointer;
      }
    </style>
    <style id="tooltip">
      .tooltip {
        background-color: rgba(160, 240, 240, 0.9);
        border-radius: 5px;
        padding: 3px 4px;

        position: absolute;
        display: none;

        /* we need to stop the tooltip eating the hover event from the item under it*/
        pointer-events: none;
      }
    </style>
    <style id="context menu">
      .d3-context-menu {
        position: absolute;
        display: none;
        background-color: #f2f2f2;
        border-radius: 4px;

        font-family: Arial, sans-serif;
        font-size: 14px;
        min-width: 150px;
        border: 1px solid #d4d4d4;

        z-index: 999;
      }

      .d3-context-menu ol {
        list-style-type: none;
        margin: 4px 0px;
        padding: 0px;
        cursor: default;
      }

      .d3-context-menu ol li {
        padding: 4px 16px;
      }

      .d3-context-menu ol li:hover {
        background-color: #4677f8;
        color: #fefefe;
      }
    </style>
    <!--
      TODO:
      - move noise selector to the side of the graph and use colours instead of names
       - include the name in a tooltip

      - refactor levels to a class based system

      - have a custom update function for translation of a layer
       > this will probably only be used when zooming in on the map is introduced
       - this moves the values that have already been calculated instead of having to recalculate
       - then generates new values where they are needed
       - this is an optimisation
    -->
    <script src="https://d3js.org/d3.v5.min.js"></script>
    <script src="Basic menu.js"></script>
    <script src="Perlin.js"></script>
    <script src="Fades.js"></script>
    <script id="Resizer.js" type="text/javascript">
      // allows the wrapped object to be resizable
      // WIP
      function resizeWrap(object, divName, callback){
        wrapper = wrapper || document.createElement('div')
        object.parentNode.appendChild(wrapper)
        return wrapper.appendChild(object)
      }
    </script>
    <script id="Perlin.js" type="text/javascript">
      class Perlin{
        constructor(gridWidth, colourMap, canvas){
          this.canvas = canvas
          this.ctx = this.canvas.getContext("2d")

          this.gridW = gridWidth
          this.cMap = colourMap
          this.perlinLevels = []
          this.pFlag = false

          // an empty list, to be filled with Amplitudes
          // these represent the z position on the heatmap
          this.resetMaps()
        }

        // a generic method used to fully reset the perlin heatmap
        // unfortunately, we don't save the perlin map
        // this means the time complexity is O(n) (dependant on the number of levels)
        resetMaps(){
          let [w, h] = this.iDims = [this.canvas.width, this.canvas.height]
          this.perlinMap = new Array(w*h).fill(0)
          this.maxLength = w*h-1

          for(let level of this.perlinLevels){
            this.addToData(level)
          }
        }

        // enables drawing on the canvas using the specified kernel as a brush
        enableDrawing(kernel, A, T){
          this.mx = this.my = 0

          // we actually need to define these functions before using them
          // as we need to have Exactly the same function to remove the event listener
          this.downEvent = this.startDrawing.bind(this, kernel, A, T)
          this.moveEvent = this.moveBrush.bind(this)
          this.upEvent = this.endDrawing.bind(this)
          this.canvas.addEventListener("mousedown", this.downEvent)
          this.canvas.addEventListener("mousemove", this.moveEvent)
          this.canvas.addEventListener("mouseup", this.upEvent)
        }

        disableDrawing(){
          this.canvas.removeEventListener("mousedown", this.downEvent)
          this.canvas.removeEventListener("mousemove", this.moveEvent)
          this.canvas.removeEventListener("mouseup", this.upEvent)
        }

        startDrawing(kernel, A, T, e){
          let addFunc = this.kernelAdd.bind(this, kernel, A)
          this.drawInterval = setInterval(addFunc, T)
        }

        moveBrush(e){
          let rect = e.target.getBoundingClientRect()
          this.mx = e.clientX - rect.left //x position within the element.
          this.my = e.clientY - rect.top  //y position within the element.
        }

        endDrawing(e){
          clearInterval(this.drawInterval)
        }

        // adds a specified kernel at a specified (x, y) coordinate on the board
        kernelAdd(kernel, A){
          let x = Math.floor(this.mx/this.gridW)
          let y = Math.floor(this.my/this.gridW)
          // this is the wrong way around for an m*n matrix but it fits the w, h convention
          let [m, n] = [kernel[0].length, kernel.length].map(d => Math.floor(d/2))
          let [w, h] = this.iDims.map(d => Math.floor(d/this.gridW))

          // clamps the center offsets for the kernel
          // to ensure the kernel isn't applied to points outside the image
          let i = [Math.min(m, x), Math.min(m, w-x)]
          let j = [Math.min(n, y), Math.min(n, h-y)]

          // determines the offset to the top left corner of the kernel
          let kx = x-m
          let ky = y-n

          // determines the range to take from the kernel
          let kxr = [m-i[0], m+i[1]+1]
          let kyr = [n-j[0], n+j[1]+1]

          for(x=kxr[0]; x<kxr[1]; x++){
            for(y=kyr[0]; y<kyr[1]; y++){
              i = (x+kx)*this.gridW
              j = (y+ky)*this.gridW
              this.addToSection(i, j, kernel[y][x]*A)
            }
          }
          this.redrawMap()
        }

        addToData(level){
          // unpack level and bring into cache
          let [f, A, s] = level
          let [w, h] = this.iDims
          noise.seed(s)

          // we find use the longer side to ensure that only one repetition is shown on canvas
          // this should be regardless of the aspect ratio of the canvas used
          let m = Math.max(w, h)

          // loop over all the positions in the perlin grid
          for(let y = 0; y < h; y += this.gridW){
            for(let x = 0; x < w; x += this.gridW){
              // generate the noise with a range of 0 -> 1
              s = noise.perlin2(x*f/m, y*f/m)

              // the noise val to perlin.perlinData
              this.addToSection(x, y, A * s)
            }
          }
        }

        // adds a specified value to a square in perlin.perlinMap
        // the square has a side length of perlin.res
        addToSection(x, y, val){
          // define temp early on as we will be using it multiple times
          // to be frank, it isn't needed, but it helps with readability
          // and a tiny little bit with speed
          let t, w = this.iDims[0]

          // iterates over all the offsets used in the square
          for(let i = 0; i < this.gridW; i++){
            for(let j = 0; j < this.gridW; j++){
              if(x+i < w){
                t = ((y+j)*this.iDims[0])+(x+i)
                this.perlinMap[Math.min(t, this.maxLength)] += val
              }
            }
          }
        }

        // adds a new level to the pre-existing data
        addLevel(point){
          let nLevel = this.getLevel(point)
          this.perlinLevels.push(nLevel)
          this.addToData(nLevel)
          this.redrawMap()
        }

        // edits a given level
        editLevel(point){
          let [f, A, _] = this.getLevel(point)
          let [l, i] = this.fetchLevel(f)

          // if we can't find the level among the existing ones
          // this shouldn't happen
          if(i == -1){
            console.warn("This level does not exist, creating a new one instead")
            this.addLevel([f, A])
          }

          // if the Amplitude has been changed
          else if(A != l[1]){
            this.addToData([l[0], A-l[1], l[2]])
            this.perlinLevels[i][1] = A
          }

          // otherwise we don't edit the level at all and don't redraw
          else return

          this.redrawMap()
        }

        // resets a given level, by generating it over
        resetLevel(point){
          let [f, A, s] = this.getLevel(point)
          let [l, i] = this.fetchLevel(f)

          // removes the effect the previous level
          this.addToData([l[0], -l[1], l[2]])

          // adds the effect of the new level
          this.addToData([f, A, s])

          this.perlinLevels[i] = [f, A, s]
          this.redrawMap()
        }

        // deletes a level from the data and redraws the map
        // this is done in order O(1) time (dependant on the number of levels)
        delLevel(point){
          let [f, A, _] = this.getLevel(point)
          let [l, i] = this.fetchLevel(f)
          this.addToData([l[0], -l[1], l[2]])
          this.perlinLevels.splice(i, 1)
          this.redrawMap()
        }

        // translates the data from a point to a level
        getLevel(point){
          // a new level also includes a random seed
          return [2**point[0], 2**point[1], Math.random()]
        }

        // fetches a level with a matching frequency
        // we don't use a dictionary as:
        // 1) it is extremely unlikely that we will ever have more than 10 levels
        //    hence O(n) is an acceptable time complexity
        // 2) using an array makes it much more simple to iterate over the levels
        //    iterating over the levels is used to set a default
        fetchLevel(f){
          // this:
          // l[0]==f?[[...l], i]:acc
          // returns a copy of the level if the frequencies match
          // otherwise, it ignores it
          return this.perlinLevels.reduce((acc, l, i) => l[0]==f?[[...l], i]:acc, [-1, -1])
        }

        // colourScale:
        // function used to draw the terrain map
        // should take a value from 0 -> 1
        // and return a list of 4 values from 0 -> 255, representing RGBA values
        redrawMap(){
          if(this.perlinLevels.length == 0) return 0
          let max = this.perlinLevels.reduce((acc, v) => v[1]+acc, 0) * (2**0.5)
          let img = this.ctx.createImageData(...this.iDims)
          let rgba

          for(let i in this.perlinMap){
            rgba = this.cMap(this.perlinMap[i]/max + 0.5)
            img.data[4*i + 0] = rgba[0]
            img.data[4*i + 1] = rgba[1]
            img.data[4*i + 2] = rgba[2]
            img.data[4*i + 3] = rgba[3]
          }

          this.ctx.fillColor = "black"
          this.ctx.fillRect(0, 0, 100, 100)
          this.ctx.putImageData(img, 0, 0)
        }
      }
    </script>
    <script id="LevelClass.js" type="text/javascript">
      // credit to:
      // Denise Mauldin (draggable line graph)
      // https://bl.ocks.org/denisemauldin/538bfab8378ac9c3a32187b4d7aed2c2
      class Levels{
        constructor(perlin, defaults, defaultName){
          this.points = []
          this.perlin = perlin
          this.svg = d3.select("#Levels")

          this.setupLevels(defaults, defaultLevel)
        }

        setupLevels(defaults, defaultLevel){
          let dims = this.getDims(defaults["margin"])
          this.createFocus(dims, defaults["margin"])
          this.createAxis(dims, defaults["margin"])
          this.createDraggable()
        }

        getDims(margin){
          w = +this.svg.attr("width") - margin.left - margin.right,
          h = +this.svg.attr("height") - margin.top - margin.bottom
          return [w, h]
        }

        createFocus(dims, margin){
          svg.append('rect')
             .attr('class', 'zoom')
             .attr('fill', 'none')
             .attr('pointer-events', 'all')
             .attr('width', dims[0])
             .attr('height', dims[1])
             .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')')

          this.focus = svg.append("g")
                          .attr("transform", "translate(" + margin.left + "," + margin.top + ")")
        }

        createAxis(dims, margin){
          // sets up the x axis for the graph
          // sets up the function to transform x values to points
          this.x = d3.scaleLinear()
                     .rangeRound([0, dims[0]])
                     .domain([0, 8])

          // sets up the displayed x axis
          this.focus.append('g')
                    .attr('class', 'axis axis--x')
                    .attr('transform', 'translate(0,' + height + ')')
                    .call(d3.axisBottom(this.x))

          this.focus.append("text")
                    .attr("class", "x label")
                    .attr("text-anchor", "top")
                    .attr("x", dims[0] / 2 - 50)
                    .attr("y", dims[1] + 40)
                    .text("Frequency (log2)")

          // sets up the y axis for the graph
          // sets up the function to transform x values to points
          this.y = d3.scaleLinear()
                     .rangeRound([0, dims[1]])
                     .domain([-20, 0])
                     .clamp(true)

          // sets up the displayed y axis
          this.focus.append('g')
                    .attr('class', 'axis axis--y')
                    .call(d3.axisLeft(this.y))

          this.focus.append("text")
                    .attr("class", "y label")
                    .attr("text-anchor", "top")
                    .attr("transform", "rotate(-90)")
                    .attr("x", -dims[1] / 2 - 50)
                    .attr("y", -40)
                    .text("Amplitude (log2)")
        }

        createDrag(){
          let perlin = this.perlin,
              x = this.x,
              y = this.y,
              line = this.line

          function dragstarted(d){
            d3.select(this).raise().classed('active', true)
          }

          function dragged(d){
            d[1] = y.invert(d3.event.y)
            d3.select(this)
              .attr('cx', x(d[0]))
              .attr('cy', y(d[1]))
            focus.select('path').attr('d', line)
          }

          function dragended(d){
            d3.select(this).classed('active', false)
            perlin.editLevel(d)
          }

          this.drag = d3.drag()
                        .on("start", dragstarted)
                        .on("drag",  dragged)
                        .on("end",   dragended)
        }

        // we give a seperate method for this as menu will be used multiple times
        // it is called every time a new point is created
        createMenu(){
          this.menu = d3.menu()
                        .addEntry("Delete level", removePoint)
                        .makeDefault("Delete level")
        }

        updateGraph(points, i = -1){
          T, this.focus, points, i

          T = 500
          const t = this.focus.transition()
                              .duration(T)

          let p = this.focus.select("path.line")
          let c = this.focus.selectAll('circle.line')
          if(i != -1){
            p.datum(points)
             .transition(t)
             .attr("d", this.line)
            points.splice(i, 1)
          }
          p.datum(points)
           .on("click", d => addPoint(this, d))
           .transition()
           .duration(0)
           .delay(T)
           .attr("d", this.line)

          c.data(points, d => d[0])
           .join(enter => enter.append('circle')
                               .attr("class", "line")
                               .attr('r', 5.0)
                               .attr('cx', d => x(d[0]))
                               .attr('cy', d => y(d[1]))
                               .each(d => perlin.addLevel(d))
                               .call(enter => {
                               return enter.transition(t)
                                           .style("opacity", 1)})
                               .call(this.drag)
                               .call(this.menu),
                 update => update.each(d => perlin.editLevel(d))
                                 .call(update => {
                                 return update.transition(t)
                                              .attr('cx', d => x(d[0]))
                                              .attr('cy', d => y(d[1]))
                                 }),
                 exit => exit.each(d => perlin.delLevel(d))
                             .call(exit => {
                             return exit.transition(t)
                                        .style("opacity", 0)
                                        .remove()}))

        }

        addPoint(self, d){
          let coords = d3.mouse(this)

          let n = [x.invert(coords[0]),
                   y.invert(coords[1])]

          points.push(n)
          self.updateGraph(points)
        }

        removePoint = function(d){
          d3.event.preventDefault()

          let i = points.indexOf(d)

          if(i > 0 && i < points.length - 1){
            points = flattenPoint(points, i)
            updateGraph(points, i)
          }
        }

        flattenPoint = function(points, i){
          const x = points[i][0]
          const [x1, y1] = points[i - 1]
          const [x2, y2] = points[i + 1]
          const t = (x - x1) / (x2 - x1)
          let y = y2 * t + y1 * (1 - t)
          points[i][1] = y
          return points
        }

        setDefault = function(defaultName){
        }
      }
    </script>
    <script id="Levels.js" type="text/javascript">
      // credit to:
      // Denise Mauldin (draggable line graph)
      // https://bl.ocks.org/denisemauldin/538bfab8378ac9c3a32187b4d7aed2c2

      function initLevels(perlin, defaults, defaultLevel){
        let defaultLevels = defaults["points"],
            points = [],
            svg = d3.select("#Levels"),
            margin = defaults["margins"],
            width = +svg.attr("width") - margin.left - margin.right,
            height = +svg.attr("height") - margin.top - margin.bottom,
            focus = svg.append("g")
                       .attr("transform", "translate(" + margin.left + "," + margin.top + ")")

        console.log()
        let x = d3.scaleLinear()
                  .rangeRound([0, width])
                  .domain([0, 8])

        let y = d3.scaleLinear()
                  .rangeRound([height, 0])
                  .domain([-20, 0])
                  .clamp(true)

        createAxis(focus, [width, height], x, y)//>

        focus.append("path")
             .attr("class", "line")

        let line = d3.line()
                     .x(function(d){return x(d[0])})
                     .y(function(d){return y(d[1])})

        let drag = d3.drag()
                     .on('start', dragstarted)
                     .on('drag', dragged)
                     .on('end', dragended)

        let menu = d3.menu()
                     .addEntry("Delete level", removePoint)
                     .addEntry("Reset level", perlin.resetLevel.bind(perlin))
                     .makeDefault("Delete level")

        function updateGraph(i = -1){
          T = 500
          const t = focus.transition()
                         .duration(T)

          let p = focus.select("path.line")
          let c = focus.selectAll('circle.line')
          if(i != -1){
            p.datum(points, d => d[0])
             .transition(t)
             .attr("d", line)

            points.splice(i, 1)
          }
          p.datum(points, d => d[0])
           .on("click", addPoint)
           .transition()
           .duration(0)
           .delay(T)
           .attr("d", line)

          c.data(points, d => d[0])
           .join(enter => enter.append('circle')
                               .attr("class", "line")
                               .attr('r', 5.0)
                               .attr('cx', d => x(d[0]))
                               .attr('cy', d => y(d[1]))
                               .each(d => perlin.addLevel(d))
                               .call(enter => {
                               return enter.transition(t)
                                           .style("opacity", 1)})
                               .call(drag)
                               .call(menu),
                 update => update.each(d => perlin.editLevel(d))
                                 .call(update => {
                                 return update.transition(t)
                                              .attr('cx', d => x(d[0]))
                                              .attr('cy', d => y(d[1]))
                                 }),
                 exit => exit.each(d => perlin.delLevel(d))
                             .call(exit => {
                             return exit.transition(t)
                                        .style("opacity", 0)
                                        .remove()}))
        }

        function addPoint(d){
          d3.event.preventDefault()
          let coords = d3.mouse(this)

          d = [x.invert(coords[0]),
               y.invert(coords[1])]

          points.push(d)
          points.sort((a, b) => a[0] - b[0])
          updateGraph()
        }

        function removePoint(d){
          d3.event.preventDefault()

          let i = points.indexOf(d)

          if(i > 0 && i < points.length - 1){
            points = flattenPoint(points, i)
            updateGraph(i)
          }
        }

        function flattenPoint(points, i){
          const x = points[i][0]
          const [x1, y1] = points[i - 1]
          const [x2, y2] = points[i + 1]
          const t = (x - x1) / (x2 - x1)
          let y = y2 * t + y1 * (1 - t)
          points[i][1] = y
          return points
        }

        function dragstarted(d) {
          d3.select(this).raise().classed('active', true)
        }

        function dragged(d, i) {
          d[1] = y.invert(d3.event.y)
          d3.select(this)
            .attr('cy', y(d[1]))
          focus.select('path.line').attr('d', line)
          perlin.editLevel(d)
        }

        function dragended(d) {
          d3.select(this).classed('active', false)
        }

        // updates the Levels graph with one of the default set of points
        function setDefault(d, i){
          svg.selectAll("circle.default").attr("stroke", "black")
          svg.select("#default" + i).attr("stroke", "white")

          points = d[2]
          // if it's not the custom setting
          if(d[0] != "Custom"){
            // then we perform a shallow copy to prevent the preset from being edited
            // the default points given are a nested list
            // so we need to perform a copy on two layers
            points = d[2].map(v => [...v])
          }

          updateGraph()
        }

        w = +svg.attr("width")/defaultLevels.length
        tip = d3.select("div.tooltip")
        svg.selectAll("circle.default")
           .data(defaultLevels)
           .enter()
           .append("circle")
           .attr("class", "default")
           .attr("id", (d, i) => "default" + i)
           .attr("r", 5)
           .attr("cx", (_, i) => w*(i + 0.5))
           .attr("cy", 20)
           .style("fill", d => d[1])
           .style("stroke", "black")
           .on("mouseover", function(d) {
             let elem = d3.select(this)
             tip.html(d[0] + " noise")
                .style("display", "block")
                .style("left", d3.event.pageX + 5 + "px")
                .style("top", d3.event.pageY + 5 + "px")
           })
           .on("mouseout", function(d) {
             tip.transition()
                .style("display", "none")
                .duration(500)
                .attr("opacity", 0)
           })
           .on("click", d => setDefault(d))

        setDefault(defaultLevels[defaultLevel], defaultLevel)
      }

      /* creates both axis for the line graph */
      function createAxis(focus, dims, x, y){
        // sets up the displayed x axis
        focus.append('g')
             .attr('class', 'axis axis--x')
             .attr('transform', 'translate(0,' + dims[1] + ')')
             .call(d3.axisBottom(x))

        // adds the "frequency" text label to the x-axis and positions it correctly
        focus.append("text")
             .attr("class", "x label")
             .attr("text-anchor", "top")
             .attr("x", dims[0] / 2 - 50)
             .attr("y", dims[1] + 40)
             .text("Frequency (log2)")

        // sets up the displayed y axis
        focus.append('g')
             .attr('class', 'axis axis--y')
             .call(d3.axisLeft(y))

        // adds the "frequency" text label to the x-axis and positions it correctly
        focus.append("text")
             .attr("class", "y label")
             .attr("text-anchor", "top")
             .attr("transform", "rotate(-90)")
             .attr("x", -dims[1] / 2 - 50)
             .attr("y", -40)
             .text("Amplitude (log2)")
      }
    </script>
    <script id="Main.js" type="text/javascript">
      defaultLevels = {"points":
                        [["Custom",
                          "#00cc66",
                          [[0, 0],
                           [8, 0]]],
                         ["Violet",
                          "#6600cc",
                          [[0, -20],
                           [2, -16],
                           [4, -12],
                           [6, -8],
                           [8, -4]]],
                         ["White",
                          "#ffffff",
                          [[0, 0],
                           [2, 0],
                           [4, 0],
                           [6, 0],
                           [8, 0]]],
                         ["Brown",
                          "#996633",
                          [[0, 0],
                           [2, -4],
                           [4, -8],
                           [6, -12],
                           [8, -16]]],
                         ["Pink",
                          "#cc00cc",
                          [[0, 0],
                           [2, -2],
                           [4, -4],
                           [6, -6],
                           [8, -8]]],
                         ["Blue",
                          "#3333ff",
                          [[0, -10],
                           [2, -8],
                           [4, -6],
                           [6, -4],
                           [8, -2]]]],
                       "margins":{top: 50, right: 20, bottom: 50, left: 50}}
      defaultPerlin = {"kernelFuncs":
                        {"linear": t => t,
                         "quadra": t => t*t,
                         "smooth": t => 6*t**5-15*t**4+10*t**3},
                       "colorScales":
                        {"viridis":
                          ["#440154",
                           "#482878",
                           "#3e4989",
                           "#31688e",
                           "#26828e",
                           "#1f9e89",
                           "#35b779",
                           "#6ece58",
                           "#b5de2b",
                           "#fde725"],
                         "earth":
                          ["#100154",
                           "#1161b8",
                           "#52c0d9",
                           "#6ed63a",
                           "#a5d98b",
                           "#ffffff"]}}

      // generates a circular kernel with the given radius and fade function
      function circleKernel(r, fade = t=>1){
        r--
        let l = 2*r + 1
        return [...Array(l).keys()].map(y => {
          return [...Array(l).keys()].map(x => {
            let t = 1 - Math.sqrt((x-r)*(x-r) + (y-r)*(y-r))/r
            return t < 0? 0: fade(t)
          })
        })
      }

      let pMap, kernel
      function init(){
        let earthFade = fades.hexFade(defaultPerlin.colorScales.viridis)
        let canvas = document.getElementById("hMap")

        pMap = new Perlin(2, earthFade, canvas)
        kernel = circleKernel(20, defaultPerlin.kernelFuncs.smooth)
        pMap.enableDrawing(kernel, 0.05, 100)

        initLevels(pMap, defaultLevels, 4)
      }

      function testDrawSpeed(pMap, n = 100){
        console.log("starting test...")
        let t = performance.now()
        for(let x = 0; x < n; x++){
          pMap.redrawMap()
        }
        t = Math.floor((performance.now()-t)/n)
        console.log("drawing the heatmap took: " + t + "ms on average")
      }
    </script>
  </head>
  <body  onload="init()">
    <div class="tooltip"></div>
    <svg id="Levels" width=500 height=250></svg>
    <canvas id="hMap" width=500 height=500></canvas>
    <p id="label">Placeholder</p>
  </body>
</html>
